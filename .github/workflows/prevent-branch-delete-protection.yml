name: Enforce Delete Protection on Project Branches

on:
  # Note: GitHub Actions doesn't have an event for "attempt to delete branch"
  # The 'delete' event only fires AFTER a branch is deleted (too late)
  # So we use these triggers instead:
  
  push:
    # Trigger when any branch is pushed (including new branches)
    # This ensures protection is applied as soon as a branch matching the pattern is created
    branches-ignore: []
  
  create:
    # Trigger when a new branch or tag is created
    # This catches branches created via GitHub UI or API
  
  workflow_dispatch:
    # Allow manual trigger for enforcement check
  
  schedule:
    # Safety net: Run daily to verify protection is still active
    # This ensures protection remains even if manually disabled or branch protection rules are changed
    # Daily is sufficient because:
    # - Push/create triggers handle new branches immediately
    # - Branch protection rules rarely change
    # - This is a safety net, not the primary protection mechanism
    # Alternative: Use hourly ('0 * * * *') if you need faster detection
    - cron: '0 0 * * *'  # Daily at midnight UTC

jobs:
  enforce-delete-protection:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      # Note: Branch protection requires admin access via Personal Access Token (PAT)
      # The GITHUB_TOKEN doesn't have admin permissions by default
      # You need to create a PAT with 'admin:repo' scope and store it as ADMIN_PAT secret
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Enforce delete protection on project branches
        env:
          # IMPORTANT: Branch protection requires admin permissions
          # GITHUB_TOKEN does NOT have permission to modify branch protection rules by default
          # You MUST create a Personal Access Token (PAT) with admin:repo scope
          # 
          # Steps to create PAT:
          # 1. Go to GitHub.com → Settings → Developer settings → Personal access tokens → Tokens (classic)
          # 2. Generate new token (classic) with scope: "admin:repo" (Full control of private repositories)
          # 3. Copy the token (you'll only see it once!)
          # 4. Go to your repository → Settings → Secrets and variables → Actions
          # 5. Click "New repository secret"
          # 6. Name: ADMIN_PAT, Value: paste your token
          # 7. Uncomment the line below and comment/remove the GITHUB_TOKEN line above
          # 
          # Use GH_TOKEN instead of GITHUB_TOKEN to avoid conflicts with GitHub CLI
          # GITHUB_TOKEN is reserved by GitHub Actions and causes authentication issues
          GH_TOKEN: ${{ secrets.ADMIN_PAT }}
        run: |
          # Install GitHub CLI if not available
          if ! command -v gh &> /dev/null; then
            echo "Installing GitHub CLI..."
            type -p curl >/dev/null || apt-get update && apt-get install -y curl
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
            chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | tee /etc/apt/sources.list.d/github-cli.list > /dev/null
            apt-get update && apt-get install -y gh
          fi
          
          # GitHub CLI automatically uses GH_TOKEN environment variable for authentication
          # No need to run 'gh auth login' when GH_TOKEN is set
          echo "GitHub CLI will use GH_TOKEN environment variable for authentication"
          
          # Branches that MUST have delete protection (using same pattern as prevent-project-merge)
          # In monorepo, these branches represent individual projects and should be protected
          
          # Determine which branch to check based on trigger
          EVENT_NAME="${{ github.event_name }}"
          echo "Workflow triggered by: $EVENT_NAME"
          
          if [ "$EVENT_NAME" = "push" ]; then
            # For push event, use ref_name (e.g., refs/heads/branch-name -> branch-name)
            TRIGGER_BRANCH="${{ github.ref_name }}"
            echo "Push event detected. Branch: $TRIGGER_BRANCH"
          elif [ "$EVENT_NAME" = "create" ]; then
            # For create event, ref is the full ref (refs/heads/branch-name or refs/tags/tag-name)
            REF="${{ github.event.ref }}"
            REF_TYPE="${{ github.event.ref_type }}"
            echo "Create event detected. Ref: $REF, Type: $REF_TYPE"
            
            if [ "$REF_TYPE" != "branch" ]; then
              echo "Not a branch (type: $REF_TYPE), skipping"
              exit 0
            fi
            
            # Extract branch name from ref (refs/heads/branch-name -> branch-name)
            TRIGGER_BRANCH=$(echo "$REF" | sed 's|refs/heads/||')
            echo "Branch name extracted: $TRIGGER_BRANCH"
          else
            # For manual trigger or schedule: check all branches
            echo "Checking all branches that should have delete protection..."
            BRANCHES=$(gh api repos/${{ github.repository }}/branches --jq '.[].name' || echo "")
            
            if [ -z "$BRANCHES" ]; then
              echo "⚠️  No branches found or API access denied"
              exit 0
            fi
            
            # Process all branches (skip to loop)
            TRIGGER_BRANCH=""
          fi
          
          # If we have a specific branch from push/create event, check it
          if [ -n "$TRIGGER_BRANCH" ]; then
            echo "Checking triggered branch: $TRIGGER_BRANCH"
            
            # Check if it matches the pattern
            case "$TRIGGER_BRANCH" in
              project-*|test-*)
                echo "✅ Branch matches protected pattern"
                BRANCHES="$TRIGGER_BRANCH"
                ;;
              *)
                echo "Branch $TRIGGER_BRANCH does not match protected pattern (project-*|test-*), skipping"
                exit 0
                ;;
            esac
          fi
          
          for BRANCH in $BRANCHES; do
            # Check if branch matches protected pattern
            case "$BRANCH" in
              project-*|test-*)
                echo "Checking branch: $BRANCH"
                
                # Get branch protection status
                PROTECTION=$(gh api repos/${{ github.repository }}/branches/$BRANCH/protection 2>/dev/null || echo "{}")
                
                # Check if delete protection is enabled (allow_deletions: false means delete protection is ON)
                ALLOW_DELETIONS=$(echo "$PROTECTION" | jq -r '.allow_deletions.enabled // true')
                
                if [ "$ALLOW_DELETIONS" = "true" ]; then
                  echo "⚠️  Branch $BRANCH does NOT have delete protection"
                  echo "Enabling delete protection for $BRANCH to prevent accidental deletion..."
                  
                  # Enable delete protection (set allow_deletions to false)
                  # Preserve existing protection settings if any
                  if [ "$PROTECTION" != "{}" ]; then
                    # Branch has existing protection, update only allow_deletions
                    echo "Updating existing protection rules..."
                    RESULT=$(gh api \
                      -X PUT \
                      repos/${{ github.repository }}/branches/$BRANCH/protection \
                      -f allow_deletions=false \
                      --jq '.' 2>&1)
                    
                    if [ $? -eq 0 ]; then
                      echo "✅ Successfully enabled delete protection for $BRANCH"
                    else
                      echo "❌ Failed to update protection for $BRANCH"
                      echo "Error details: $RESULT"
                      echo "⚠️  This may require admin permissions or Personal Access Token (PAT)"
                      echo "⚠️  Check if ADMIN_PAT secret is configured if GITHUB_TOKEN doesn't work"
                      exit 1
                    fi
                  else
                    # Branch has no protection, create minimal protection with delete protection only
                    echo "Creating new protection rules..."
                    RESULT=$(gh api \
                      -X PUT \
                      repos/${{ github.repository }}/branches/$BRANCH/protection \
                      -f allow_deletions=false \
                      -f required_status_checks=null \
                      -f enforce_admins=null \
                      -f required_pull_request_reviews=null \
                      -f restrictions=null \
                      --jq '.' 2>&1)
                    
                    if [ $? -eq 0 ]; then
                      echo "✅ Successfully created delete protection for $BRANCH"
                    else
                      echo "❌ Failed to create protection for $BRANCH"
                      echo "Error details: $RESULT"
                      echo "⚠️  This may require admin permissions or Personal Access Token (PAT)"
                      echo "⚠️  Check if ADMIN_PAT secret is configured if GITHUB_TOKEN doesn't work"
                      exit 1
                    fi
                  fi
                else
                  echo "✅ Branch $BRANCH already has delete protection enabled"
                fi
                ;;
              *)
                # Skip branches that don't match pattern
                ;;
            esac
          done
          
          echo ""
          echo "Summary: All project branches (project-*, test-*) should now be protected from deletion."
